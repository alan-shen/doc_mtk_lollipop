===============================================================================================================
http://blog.csdn.net/21cnbao/article/details/8457546
http://blog.csdn.net/beyondioi/article/details/18674927

===============================================================================================================
                                    ARM Linux 3.x 的设备树(Device Tree):
                                    ++++++++++++++++++++++++++++++++++++

===============================================================================================================
1.ARM Device Tree:
++++++++++++++++++

	均起源于 OpenFirmware(OF)

	---------------------------------------
	PowerPC || Flattened Device Tree（FDT）
	ARM     || ARM Device Tree
	---------------------------------------

	Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点.
	所谓属性，其实就是成对出现的name和value.

	在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）:

		(1) CPU的数量和类别
		(2) 内存基地址和大小
		(3) 总线和桥
		(4) 外设连接
		(5) 中断控制器和中断使用情况
		(6) GPIO控制器和GPIO使用情况
		(7) Clock控制器和Clock使用情况

	它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader(eg.LK)会将这棵树传递给内核，然后内核可以识别这棵树，
	并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备，
	而这些设备用到的内存、IRQ等资源，也被传递给了内核，
	内核会将这些资源绑定给展开的相应的设备。

===============================================================================================================
2.Device Tree 的组成和结构:
+++++++++++++++++++++++++++

	2.1 DTS(Device Tree Source)

		PATH  -> arch/arm64/boot/dts/
		.dts  -> 一个 .dts  文件对应于一个ARM的 Machine;
		.dtsi -> 一个 .dtsi 文件是将同一个 Soc 共同的部分提炼出来,类似于C语言的头文件.

	2.2 DTC(Device Tree Compiler)

		将 .dts 编译成 .dtb 的工具.		
		PATH  -> scripts/dtc

		-----------------------------------------------------------------------------------------------------------------------
		scripts/dtc/Makefile       ||  hostprogs-y := dtc                  || 这一 hostprogs 编译target.
		arch/arm/boot/dts/Makefile ||  dtb-$(CONFIG_ARCH_XXX) += xxxx.dtb  || 描述了当某种SoC被选中后，哪些.dtb文件会被编译出来
		-----------------------------------------------------------------------------------------------------------------------

	2.3 DTB(Device Tree Blob)

		.dtb是.dts被DTC编译后的二进制格式的Device Tree描述，可由Linux内核解析。
		通常在我们为电路板制作NAND、SD启动image时，会为.dtb文件单独留下一个很小的区域以存放之，
		之后bootloader在引导kernel的过程中，会先读取该.dtb到内存。

	2.4 Binding

		Documentation/devicetree/bindings || 对于Device Tree中的结点和属性具体是如何来描述设备的硬件细节的，一般需要文档来进行讲解，文档的后缀名一般为.txt

	2.5 Bootloader(uboot/lk)

		Uboot 

			Uboot mainline 从 v1.1.3开始支持Device Tree，其对ARM的支持则是和ARM内核支持Device Tree同期完成.

		LK

			--

===============================================================================================================
3.Device Tree引发的BSP和驱动变更:
+++++++++++++++++++++++++++++++++

	有了Device Tree后，大量的板级信息都不再需要，譬如过去经常在arch/arm/plat-xxx和arch/arm/mach-xxx实施的如下事情：

		1.注册platform_device，绑定resource，即内存、IRQ等板级信息.
		2.注册i2c_board_info，指定IRQ等板级信息.
		3.注册spi_board_info，指定IRQ等板级信息.
		4.多个针对不同电路板的machine，以及相关的callback.

===============================================================================================================
4.常用 OF API:
++++++++++++++

	在Linux的BSP和驱动代码中, 还经常会使用到Linux中一组Device Tree的API,这些API通常被冠以of_前缀,
	它们的实现代码位于内核的drivers/of目录.

	... ...

	...	...

===============================================================================================================
5.总结:
+++++++

	ARM社区一贯充斥的大量垃圾代码导致Linus盛怒，因此社区在2011年到2012年进行了大量的工作。
	ARM Linux开始围绕Device Tree展开，
		Device Tree有自己的独立的语法，
		它的源文件为.dts，
		编译后得到.dtb，
		Bootloader在引导Linux内核的时候会将.dtb地址告知内核。
		之后内核会展开Device Tree并创建和注册相关的设备，
	因此
		arch/arm/mach-xxx和arch/arm/plat-xxx中大量的用于注册platform、I2C、SPI板级信息的代码被删除，
		而驱动也以新的方式和.dts中定义的设备结点进行匹配。

===============================================================================================================

